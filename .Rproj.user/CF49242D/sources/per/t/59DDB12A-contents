#include "hamiltonian.h"

double Hamiltonian::f(arma::vec x) {
  return arma::as_scalar(.5 * (x - this->mu).t() * this->Prec * (x - this->mu));
}

arma::vec Hamiltonian::df(arma::vec x) {
  return this->Prec * (x - this->mu);
}

double Hamiltonian::H(arma::vec z) {
  arma::vec x = z.rows(0, this->d-1);
  arma::vec v = z.rows(this->d, z.size()-1);
  // arma::sp_mat hess_inv = this->barrier.hessian_inv(x);
  arma::vec H = this->barrier.hessian_internal(x);
  arma::vec hess_inv = 1 / H;
  // Rcpp::Rcout << "H_inv: " << hess_inv << std::endl;
  arma::vec g_inv_v = hess_inv % v;
  double e = .5 * arma::as_scalar(v.t() * g_inv_v);
  
  // arma::sp_mat H = this->barrier.hessian(x);
  // Rcpp::Rcout << "H: " << H << std::endl;
  // arma::mat dense_H(H);
  // arma::vec diag = H.diag();
  // e = e + arma::sum(arma::log(dense_H.diag())) * .5 + this->f(x);
  e = e + arma::sum(arma::log(H)) * .5 + this->f(x);
  return e;
}

arma::vec Hamiltonian::dH(arma::vec z) {
  arma::vec x = z.rows(0, this->d-1);
  arma::vec v = z.rows(this->d, z.size()-1);
  // arma::vec result(2 * z.size());
  
  if (z.has_nan() || !this->barrier.feasible(x)) {
    arma::vec dz(z.size());
    return dz.fill(arma::datum::nan);
  }
  
  // arma::sp_mat hess_inv = this->barrier.hessian_inv(x);
  // arma::vec g_inv_v = hess_inv * v;
  arma::vec g_inv_v = (1 / this->barrier.hessian_internal(x)) % v;
  
  arma::vec sigma = this->barrier.log_det_gradient(x);
  
  arma::vec dx = g_inv_v;
  arma::vec dv = 
    -this->df(x) + .5 * this->barrier.quadratic_form_gradient(x, dx) - .5 * sigma;
  // result.head(z.size()) = dx;
  // result.tail(z.size()) = dv;
  // return result;
  return arma::join_cols(dx, dv);
}

double Hamiltonian::stepsize(arma::vec z, arma::vec dz) {
  arma::vec x = z.rows(0, this->d-1);
  arma::vec dx = dz.rows(0, this->d-1);
  double t1 = this->barrier.stepsize(x, dx);
  double t2 = 1 / arma::max(arma::sqrt(this->barrier.hessian_norm(x, dx)));
  return std::min(t1, arma::min(t2));
}

arma::vec Hamiltonian::generate(arma::vec x) {
  arma::vec gv = arma::sqrt(this->barrier.hessian_internal(x)) % arma::randn(this->d);
  return arma::join_cols(x, gv);
}

void Hamiltonian::generateJL() {
  this->JLdir = arma::sign(arma::randn(this->d, this->JLsize)) / std::sqrt(this->JLsize);
}

